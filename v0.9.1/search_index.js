var documenterSearchIndex = {"docs":
[{"location":"pages/api/#Finite-Differences-1","page":"API","title":"Finite Differences","text":"","category":"section"},{"location":"pages/api/#","page":"API","title":"API","text":"FiniteDifferenceMethod\nfdm\nbackward_fdm\ncentral_fdm\nforward_fdm\nassert_approx_equal\nFiniteDifferences.DEFAULT_CONDITION\nFiniteDifferences.TINY","category":"page"},{"location":"pages/api/#FiniteDifferences.FiniteDifferenceMethod","page":"API","title":"FiniteDifferences.FiniteDifferenceMethod","text":"FiniteDifferenceMethod\n\nAbstract type for all finite differencing method types. Subtypes of FiniteDifferenceMethod are callable with the signature\n\nmethod(f, x; kwargs...)\n\nwhere the keyword arguments can be any of\n\nadapt: The number of adaptive steps to use improve the estimate of bound.\nbound: Bound on the value of the function and its derivatives at x.\ncondition: The condition number. See DEFAULT_CONDITION.\neps: The assumed roundoff error. Defaults to eps() plus TINY.\n\n\n\n\n\n","category":"type"},{"location":"pages/api/#FiniteDifferences.fdm","page":"API","title":"FiniteDifferences.fdm","text":"fdm(m::FiniteDifferenceMethod, f, x[, Val(false)]; kwargs...) -> Real\nfdm(m::FiniteDifferenceMethod, f, x, Val(true); kwargs...) -> Tuple{FiniteDifferenceMethod, Real}\n\nCompute the derivative of f at x using the finite differencing method m. The optional Val argument dictates whether the method should be returned alongside the derivative value, which can be useful for examining the step size used and other such parameters.\n\nThe recognized keywords are:\n\nadapt: The number of adaptive steps to use improve the estimate of bound.\nbound: Bound on the value of the function and its derivatives at x.\ncondition: The condition number. See DEFAULT_CONDITION.\neps: The assumed roundoff error. Defaults to eps() plus TINY.\n\nwarning: Warning\nBounds can't be adaptively computed over nonstandard grids; passing a value for adapt greater than 0 when m::Nonstandard results in an error.\n\nnote: Note\nCalling FiniteDifferenceMethod objects is equivalent to passing them to fdm.\n\nExamples\n\njulia> fdm(central_fdm(5, 1), sin, 1; adapt=2)\n0.5403023058681039\n\njulia> fdm(central_fdm(2, 1), exp, 0, Val(true))\n(FiniteDifferenceMethod:\n  order of method:       2\n  order of derivative:   1\n  grid:                  [-1, 1]\n  coefficients:          [-0.5, 0.5]\n  roundoff error:        1.42e-14\n  bounds on derivatives: 1.00e+02\n  step size:             1.69e-08\n  accuracy:              1.69e-06\n, 1.0000000031817473)\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#FiniteDifferences.backward_fdm","page":"API","title":"FiniteDifferences.backward_fdm","text":"FiniteDifferences.Backward(p, q; kwargs...)\nbackward_fdm(p, q; kwargs...)\n\nConstruct a backward finite difference method of order p to compute the qth derivative. See FiniteDifferenceMethod for more details.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#FiniteDifferences.central_fdm","page":"API","title":"FiniteDifferences.central_fdm","text":"FiniteDifferences.Central(p, q; kwargs...)\ncentral_fdm(p, q; kwargs...)\n\nConstruct a central finite difference method of order p to compute the qth derivative. See FiniteDifferenceMethod for more details.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#FiniteDifferences.forward_fdm","page":"API","title":"FiniteDifferences.forward_fdm","text":"FiniteDifferences.Forward(p, q; kwargs...)\nforward_fdm(p, q; kwargs...)\n\nConstruct a forward finite difference method of order p to compute the qth derivative. See FiniteDifferenceMethod for more details.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#FiniteDifferences.assert_approx_equal","page":"API","title":"FiniteDifferences.assert_approx_equal","text":"assert_approx_equal(x, y, ε_abs, ε_rel[, desc])\n\nAssert that x is approximately equal to y.\n\nLet eps_z = eps_abs / eps_rel. Call x and y small if abs(x) < eps_z and abs(y) < eps_z, and call x and y large otherwise.  If this function returns True, then it is guaranteed that abs(x - y) < 2 eps_rel max(abs(x), abs(y)) if x and y are large, and abs(x - y) < 2 eps_abs if x and y are small.\n\nArguments\n\nx: First object to compare.\ny: Second object to compare.\nε_abs: Absolute tolerance.\nε_rel: Relative tolerance.\ndesc: Description of the comparison. Omit or set to false to have no description.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#FiniteDifferences.DEFAULT_CONDITION","page":"API","title":"FiniteDifferences.DEFAULT_CONDITION","text":"FiniteDifferences.DEFAULT_CONDITION\n\nThe default condition number used when computing bounds. It provides amplification of the ∞-norm when passed to the function's derivatives.\n\n\n\n\n\n","category":"constant"},{"location":"pages/api/#FiniteDifferences.TINY","page":"API","title":"FiniteDifferences.TINY","text":"FiniteDifferences.TINY\n\nA tiny number added to some quantities to ensure that division by 0 does not occur.\n\n\n\n\n\n","category":"constant"},{"location":"pages/api/#Gradients-1","page":"API","title":"Gradients","text":"","category":"section"},{"location":"pages/api/#","page":"API","title":"API","text":"grad\njacobian\njvp\nj′vp\nto_vec","category":"page"},{"location":"pages/api/#FiniteDifferences.grad","page":"API","title":"FiniteDifferences.grad","text":"grad(fdm, f, xs...)\n\nApproximate the gradient of f at xs... using fdm. Assumes that f(xs...) is scalar.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#FiniteDifferences.jacobian","page":"API","title":"FiniteDifferences.jacobian","text":"jacobian(fdm, f, xs::Union{Real, AbstractArray{<:Real}}; len::Int=length(f(x)))\n\nApproximate the Jacobian of f at x using fdm. f(x) must be a length len vector. If len is not provided, then f(x) is computed once to determine the output size.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#FiniteDifferences.jvp","page":"API","title":"FiniteDifferences.jvp","text":"jvp(fdm, f, x, ẋ)\n\nCompute a Jacobian-vector product with any types of arguments for which to_vec is defined.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#FiniteDifferences.j′vp","page":"API","title":"FiniteDifferences.j′vp","text":"j′vp(fdm, f, ȳ, x...)\n\nCompute an adjoint with any types of arguments for which to_vec is defined.\n\n\n\n\n\n","category":"function"},{"location":"pages/api/#FiniteDifferences.to_vec","page":"API","title":"FiniteDifferences.to_vec","text":"to_vec(x) -> Tuple{<:AbstractVector, <:Function}\n\nTransform x into a Vector, and return a closure which inverts the transformation.\n\n\n\n\n\n","category":"function"},{"location":"#FiniteDifferences.jl:-Finite-Difference-Methods-1","page":"Home","title":"FiniteDifferences.jl: Finite Difference Methods","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"(Image: Build Status) (Image: codecov.io) (Image: Latest Docs)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"FiniteDifferences.jl approximates derivatives of functions using finite difference methods.","category":"page"},{"location":"#Examples-1","page":"Home","title":"Examples","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Compute the first derivative of sin with a 5th order central method:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> central_fdm(5, 1)(sin, 1) - cos(1)\n-1.247890679678676e-13","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Compute the second derivative of sin with a 5th order central method:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> central_fdm(5, 2)(sin, 1) + sin(1)\n9.747314066999024e-12","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Construct a FiniteDifferences on a custom grid:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> method, report = fdm([-2, 0, 5], 1, report=true)\n(FiniteDifferences.method, FiniteDifferencesReport:\n  order of method:       3\n  order of derivative:   1\n  grid:                  [-2, 0, 5]\n  coefficients:          [-0.357143, 0.3, 0.0571429]\n  roundoff error:        2.22e-16\n  bounds on derivatives: 1.00e+00\n  step size:             3.62e-06\n  accuracy:              6.57e-11\n)\n\njulia> method(sin, 1) - cos(1)\n-2.05648831297367e-11","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Compute a directional derivative:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> f(x) = sum(x)\nf (generic function with 1 method)\n\njulia> central_fdm(5, 1)(ε -> f([1, 1, 1] + ε * [1, 2, 3]), 0) - 6\n-2.922107000813412e-13","category":"page"}]
}
