<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · FiniteDifferences.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">FiniteDifferences.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Scalar-Derivatives"><span>Scalar Derivatives</span></a></li><li><a class="tocitem" href="#Multivariate-Derivatives"><span>Multivariate Derivatives</span></a></li></ul></li><li><a class="tocitem" href="pages/api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDiff/FiniteDifferences.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="FiniteDifferences.jl:-Finite-Difference-Methods"><a class="docs-heading-anchor" href="#FiniteDifferences.jl:-Finite-Difference-Methods">FiniteDifferences.jl: Finite Difference Methods</a><a id="FiniteDifferences.jl:-Finite-Difference-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#FiniteDifferences.jl:-Finite-Difference-Methods" title="Permalink"></a></h1><p><a href="https://github.com/JuliaDiff/FiniteDifferences.jl/actions?query=workflow%3ACI"><img src="https://github.com/JuliaDiff/FiniteDifferences.jl/workflows/CI/badge.svg?branch=master" alt="CI"/></a> <a href="https://travis-ci.org/JuliaDiff/FiniteDifferences.jl"><img src="https://travis-ci.org/JuliaDiff/FiniteDifferences.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://codecov.io/github/JuliaDiff/FiniteDifferences.jl?branch=master"><img src="https://codecov.io/github/JuliaDiff/FiniteDifferences.jl/coverage.svg?branch=master" alt="codecov.io"/></a> <a href="https://juliaci.github.io/NanosoldierReports/pkgeval_badges/report.html"><img src="https://juliaci.github.io/NanosoldierReports/pkgeval_badges/F/FiniteDifferences.svg" alt="PkgEval"/></a></p><p><a href="https://juliadiff.org/FiniteDifferences.jl/latest/"><img src="https://img.shields.io/badge/docs-latest-blue.svg" alt="Latest Docs"/></a> <a href="https://github.com/invenia/BlueStyle"><img src="https://img.shields.io/badge/code%20style-blue-4495d1.svg" alt="Code Style: Blue"/></a> <a href="https://github.com/SciML/ColPrac"><img src="https://img.shields.io/badge/ColPrac-Contributor&#39;s%20Guide-blueviolet" alt="ColPrac: Contributor&#39;s Guide on Collaborative Practices for Community Packages"/></a> <a href="https://zenodo.org/badge/latestdoi/117872213"><img src="https://zenodo.org/badge/117872213.svg" alt="DOI"/></a></p><p>FiniteDifferences.jl estimates derivatives with <a href="https://en.wikipedia.org/wiki/Finite_difference">finite differences</a>.</p><p>See also the Python package <a href="https://github.com/wesselb/fdm">FDM</a>.</p><h4 id="FiniteDiff.jl-vs-FiniteDifferences.jl"><a class="docs-heading-anchor" href="#FiniteDiff.jl-vs-FiniteDifferences.jl">FiniteDiff.jl vs FiniteDifferences.jl</a><a id="FiniteDiff.jl-vs-FiniteDifferences.jl-1"></a><a class="docs-heading-anchor-permalink" href="#FiniteDiff.jl-vs-FiniteDifferences.jl" title="Permalink"></a></h4><p><a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a> and <a href="https://github.com/JuliaDiff/FiniteDifferences.jl">FiniteDifferences.jl</a> are similar libraries: both calculate approximate derivatives numerically. You should definately use one or the other, rather than the legacy <a href="https://github.com/JuliaMath/Calculus.jl">Calculus.jl</a> finite differencing, or reimplementing it yourself. At some point in the future they might merge, or one might depend on the other. Right now here are the differences:</p><ul><li>FiniteDifferences.jl supports basically any type, where as FiniteDiff.jl supports only array-ish types</li><li>FiniteDifferences.jl supports higher order approximation and step size adaptation</li><li>FiniteDiff.jl supports caching and in-place computation</li><li>FiniteDiff.jl supports coloring vectors for efficient calculation of sparse Jacobians</li></ul><h4 id="FDM.jl"><a class="docs-heading-anchor" href="#FDM.jl">FDM.jl</a><a id="FDM.jl-1"></a><a class="docs-heading-anchor-permalink" href="#FDM.jl" title="Permalink"></a></h4><p>This package was formerly called FDM.jl. We recommend users of FDM.jl <a href="https://github.com/JuliaDiff/FiniteDifferences.jl/issues/37">update to FiniteDifferences.jl</a>.</p><h4 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h4><ul><li><a href="#scalar-derivatives">Scalar Derivatives</a><ul><li><a href="#dealing-with-singularities">Dealing with Singularities</a></li><li><a href="#dealing-with-numerical-noise">Dealing with Numerical Noise</a></li><li><a href="#richardson-extrapolation">Richardson Extrapolation</a></li><li><a href="#a-finite-difference-method-on-a-custom-grid">A Finite Difference Method on a Custom Grid</a></li></ul></li><li><a href="#multivariate-derivatives">Multivariate Derivatives</a></li></ul><h2 id="Scalar-Derivatives"><a class="docs-heading-anchor" href="#Scalar-Derivatives">Scalar Derivatives</a><a id="Scalar-Derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-Derivatives" title="Permalink"></a></h2><p>Compute the first derivative of <code>sin</code> with a 5th order central method:</p><pre><code class="language-julia">julia&gt; central_fdm(5, 1)(sin, 1) - cos(1)
-2.4313884239290928e-14</code></pre><p>Finite difference methods are optimised to minimise allocations:</p><pre><code class="language-julia">julia&gt; m = central_fdm(5, 1);

julia&gt; @benchmark $m(sin, 1)
BenchmarkTools.Trial:
  memory estimate:  0 bytes
  allocs estimate:  0
  --------------
  minimum time:     486.621 ns (0.00% GC)
  median time:      507.677 ns (0.00% GC)
  mean time:        539.806 ns (0.00% GC)
  maximum time:     1.352 μs (0.00% GC)
  --------------
  samples:          10000
  evals/sample:     195</code></pre><p>Compute the second derivative of <code>sin</code> with a 5th order central method:</p><pre><code class="language-julia">julia&gt; central_fdm(5, 2)(sin, 1) - (-sin(1))
-8.767431225464861e-11</code></pre><p>To obtain better accuracy, you can increase the order of the method:</p><pre><code class="language-julia">julia&gt; central_fdm(12, 2)(sin, 1) - (-sin(1))
5.240252676230739e-14</code></pre><p>The functions <code>forward_fdm</code> and <code>backward_fdm</code> can be used to construct forward differences and backward differences respectively.</p><h3 id="Dealing-with-Singularities"><a class="docs-heading-anchor" href="#Dealing-with-Singularities">Dealing with Singularities</a><a id="Dealing-with-Singularities-1"></a><a class="docs-heading-anchor-permalink" href="#Dealing-with-Singularities" title="Permalink"></a></h3><p>The function <code>log(x)</code> is only defined for <code>x &gt; 0</code>. If we try to use <code>central_fdm</code> to estimate the derivative of <code>log</code> near <code>x = 0</code>, then we run into <code>DomainError</code>s, because <code>central_fdm</code> happens to evaluate <code>log</code> at some <code>x &lt; 0</code>.</p><pre><code class="language-julia">julia&gt; central_fdm(5, 1)(log, 1e-3)
ERROR: DomainError with -0.02069596546590111</code></pre><p>To deal with this situation, you have two options.</p><p>The first option is to use <code>forward_fdm</code>, which only evaluates <code>log</code> at inputs greater or equal to <code>x</code>:</p><pre><code class="language-julia">julia&gt; forward_fdm(5, 1)(log, 1e-3) - 1000
-3.741856744454708e-7</code></pre><p>This works fine, but the downside is that you&#39;re restricted to one-sided methods (<code>forward_fdm</code>), which tend to perform worse than central methods (<code>central_fdm</code>).</p><p>The second option is to limit the distance that the finite difference method is allowed to evaluate <code>log</code> away from <code>x</code>. Since <code>x = 1e-3</code>, a reasonable value for this limit is <code>9e-4</code>:</p><pre><code class="language-julia">julia&gt; central_fdm(5, 1, max_range=9e-4)(log, 1e-3) - 1000
-4.027924660476856e-10</code></pre><p>Another commonly encountered example is <code>logdet</code>, which is only defined for positive-definite matrices. Here you can use a forward method in combination with a positive-definite deviation from <code>x</code>:</p><pre><code class="language-julia">julia&gt; x = diagm([1.0, 2.0, 3.0]); v = Matrix(1.0I, 3, 3);

julia&gt; forward_fdm(5, 1)(ε -&gt; logdet(x .+ ε .* v), 0) - sum(1 ./ diag(x))
-4.222400207254395e-12</code></pre><p>A range-limited central method is also possible:</p><pre><code class="language-julia">julia&gt; central_fdm(5, 1, max_range=9e-1)(ε -&gt; logdet(x .+ ε .* v), 0) - sum(1 ./ diag(x))
-1.283417816466681e-13</code></pre><h3 id="Dealing-with-Numerical-Noise"><a class="docs-heading-anchor" href="#Dealing-with-Numerical-Noise">Dealing with Numerical Noise</a><a id="Dealing-with-Numerical-Noise-1"></a><a class="docs-heading-anchor-permalink" href="#Dealing-with-Numerical-Noise" title="Permalink"></a></h3><p>It could be the case that the function <code>f</code> you&#39;d like compute the derivative of suffers from numerical noise. For example, <code>f(x)</code> could be computed through some iterative procedure with some error tolerance <code>ε</code>. In such cases, finite difference estimates can fail catastrophically. To illustrate this, consider <code>sin_noisy(x) = sin(x) * (1 + 1e-6 * randn())</code>. Then</p><pre><code class="language-julia">julia&gt; central_fdm(5, 1)(sin_noisy, 1) - cos(1)
-0.027016678790599657</code></pre><p>which is a terrible performance. To deal with this, you can set the keyword argument <code>factor</code>, which specifies the level of numerical noise on the function evaluations relative to the machine epsilon. In this example, the relative error on the function evaluations is <code>2e-6</code> (<code>1e-6 * randn()</code> roughly produces a number in <code>[-2e-6, 2e-6]</code>) and the machine epsilon is <code>eps(Float64) ≈ 2.22e-16</code>, so <code>factor = 2e-6 / 2e-16 = 1e10</code> should be appropriate:</p><pre><code class="language-julia">julia&gt; central_fdm(5, 1; factor=1e10)(sin_noisy, 1) - cos(1)
-1.9243663490486895e-6</code></pre><p>As a rule of thumb, if you&#39;re dealing with numerical noise and <code>Float64</code>s, <code>factor = 1e6</code> is not a bad first attempt.</p><h3 id="Richardson-Extrapolation"><a class="docs-heading-anchor" href="#Richardson-Extrapolation">Richardson Extrapolation</a><a id="Richardson-Extrapolation-1"></a><a class="docs-heading-anchor-permalink" href="#Richardson-Extrapolation" title="Permalink"></a></h3><p>The finite difference methods defined in this package can be extrapolated using <a href="https://github.com/JuliaMath/Richardson.jl">Richardson extrapolation</a>. This can offer superior numerical accuracy: Richardson extrapolation attempts polynomial extrapolation of the finite difference estimate as a function of the step size until a convergence criterion is reached.</p><pre><code class="language-julia">julia&gt; extrapolate_fdm(central_fdm(2, 1), sin, 1)[1] - cos(1)
1.6653345369377348e-14</code></pre><p>Similarly, you can estimate higher order derivatives:</p><pre><code class="language-julia">julia&gt; extrapolate_fdm(central_fdm(5, 4), sin, 1)[1] - sin(1)
-1.626274487942503e-5</code></pre><p>In this case, the accuracy can be improved by making the <a href="https://github.com/JuliaMath/Richardson.jl#usage">contraction rate</a> closer to <code>1</code>:</p><pre><code class="language-julia">julia&gt; extrapolate_fdm(central_fdm(5, 4), sin, 1, contract=0.8)[1] - sin(1)
2.0725743343774639e-10</code></pre><p>This performs similarly to a <code>10</code>th order central method:</p><pre><code class="language-julia">julia&gt; central_fdm(10, 4)(sin, 1) - sin(1)
-1.0301381969668455e-10</code></pre><p>If you really want, you can even extrapolate the <code>10</code>th order central method, but that provides no further gains:</p><pre><code class="language-julia">julia&gt; extrapolate_fdm(central_fdm(10, 4), sin, 1, contract=0.8)[1] - sin(1)
5.673617131662922e-10</code></pre><p>In this case, the central method can be pushed to a high order to obtain improved accuracy:</p><pre><code class="language-julia">julia&gt; central_fdm(20, 4)(sin, 1) - sin(1)
-5.2513549064769904e-14</code></pre><h3 id="A-Finite-Difference-Method-on-a-Custom-Grid"><a class="docs-heading-anchor" href="#A-Finite-Difference-Method-on-a-Custom-Grid">A Finite Difference Method on a Custom Grid</a><a id="A-Finite-Difference-Method-on-a-Custom-Grid-1"></a><a class="docs-heading-anchor-permalink" href="#A-Finite-Difference-Method-on-a-Custom-Grid" title="Permalink"></a></h3><pre><code class="language-julia">julia&gt; method = FiniteDifferenceMethod([-2, 0, 5], 1)
FiniteDifferenceMethod:
  order of method:       3
  order of derivative:   1
  grid:                  [-2, 0, 5]
  coefficients:          [-0.35714285714285715, 0.3, 0.05714285714285714]

julia&gt; method(sin, 1) - cos(1)
-3.701483564100272e-13</code></pre><h2 id="Multivariate-Derivatives"><a class="docs-heading-anchor" href="#Multivariate-Derivatives">Multivariate Derivatives</a><a id="Multivariate-Derivatives-1"></a><a class="docs-heading-anchor-permalink" href="#Multivariate-Derivatives" title="Permalink"></a></h2><p>Consider a quadratic function:</p><pre><code class="language-julia">julia&gt; a = randn(3, 3); a = a * a&#39;
3×3 Matrix{Float64}:
  4.31995    -2.80614   0.0829128
 -2.80614     3.91982   0.764388
  0.0829128   0.764388  1.18055

julia&gt; f(x) = 0.5 * x&#39; * a * x</code></pre><p>Compute the gradient:</p><pre><code class="language-julia">julia&gt; x = randn(3)
3-element Vector{Float64}:
 -0.18563161988700727
 -0.4659836395595666
  2.304584409826511

julia&gt; grad(central_fdm(5, 1), f, x)[1] - a * x
3-element Vector{Float64}:
  4.1744385725905886e-14
 -6.611378111642807e-14
 -8.615330671091215e-14</code></pre><p>Compute the Jacobian:</p><pre><code class="language-julia">julia&gt; jacobian(central_fdm(5, 1), f, x)[1] - (a * x)&#39;
1×3 Matrix{Float64}:
 4.17444e-14  -6.61138e-14  -8.61533e-14</code></pre><p>The Jacobian can also be computed for non-scalar functions:</p><pre><code class="language-julia">julia&gt; a = randn(3, 3)
3×3 Matrix{Float64}:
  0.844846   1.04772    1.0173
 -0.867721   0.154146  -0.938077
  1.34078   -0.630105  -1.13287

julia&gt; f(x) = a * x

julia&gt; jacobian(central_fdm(5, 1), f, x)[1] - a
3×3 Matrix{Float64}:
  2.91989e-14   1.77636e-15   4.996e-14
 -5.55112e-15  -7.63278e-15   2.4758e-14
  4.66294e-15  -2.05391e-14  -1.04361e-14</code></pre><p>To compute Jacobian–vector products, use <code>jvp</code> and <code>j′vp</code>:</p><pre><code class="language-julia">julia&gt; v = randn(3)
3-element Array{Float64,1}:
 -1.290782164377614
 -0.37701592844250903
 -1.4288108966380777

julia&gt; jvp(central_fdm(5, 1), f, (x, v)) - a * v
3-element Vector{Float64}:
 -7.993605777301127e-15
 -8.881784197001252e-16
 -3.22519788653608e-14

julia&gt; j′vp(central_fdm(5, 1), f, x, v)[1] - a&#39;x
3-element Vector{Float64}:
 -2.1316282072803006e-14
  2.4646951146678475e-14
  6.661338147750939e-15</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="pages/api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 23 July 2021 11:44">Friday 23 July 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
